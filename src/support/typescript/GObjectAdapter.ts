import ts from 'typescript';

/**
 * Class to adapt the javascript generated by typescript for GObjects. The transformer only affacts classes decorated 
 * with @registerGObject. Currently the following modifications are applied:
 *
 * 1) The constructor is converted to an _init() method with the same parameters.
 * 2) Any reference to the super constructor is translated to super._init() with the same parameters.
 *
 * This changes are needed for compatibility with GNOME 41. object constructor is in fact supported only from GJS 1.72 
 * aka GNOME 42.
 */
export default class GObjectAdapter {

    private static readonly GOBJECT_ANNOTATION = '@registerGObject';

    private gobjects: string[];

    public constructor() {
        this.gobjects = [];
    }

    public beforeCompilation(context: ts.TransformationContext): ts.Transformer<ts.SourceFile> {
        return sourceFile => {
            const visitor = (node: ts.Node): ts.Node => {
                if (ts.isClassDeclaration(node) && this.isDecoratedClass(node, GObjectAdapter.GOBJECT_ANNOTATION)) {
                    const className = node.name?.text;
                    if (className !== undefined) {
                        console.log(`[GObjectAdapter::beforeCompilation] Class ${className} is a GObject. Marked for modification.`);
                        this.gobjects.push(className);
                    }

                    return node;
                }

                return ts.visitEachChild(node, visitor, context);
            };

            return ts.visitNode(sourceFile, visitor);
        };
    }

    public afterCompilation(context: ts.TransformationContext): ts.Transformer<ts.SourceFile> {
        return sourceFile => {
            let className: string | undefined;

            const constructorBodyVisitor = (node: ts.Node): ts.Node => {
                if (ts.isExpressionStatement(node) && ts.isCallExpression(node.expression)
                        && node.expression.expression.kind == ts.SyntaxKind.SuperKeyword) {
                    console.log(`[GObjectAdapter::afterCompilation] Adapting reference to super construtor in ${className} constructor`);
                    // Return a call to super._init() with the same arguments
                    return context.factory.createExpressionStatement(
                        context.factory.createCallExpression(
                            context.factory.createPropertyAccessExpression(
                                context.factory.createSuper(),
                                '_init'
                            ),
                            node.expression.typeArguments,
                            node.expression.arguments
                        )
                    );
                }

                return node;
            };

            const gobjectClassVisitor = (node: ts.Node): ts.Node | undefined => {
                if (ts.isConstructorDeclaration(node)) {
                    console.log(`[GObjectAdapter::afterCompilation] Adapting constructor of ${className}`);
                    // Replace the constructor declaration with a _init() with the same argoment
                    return context.factory.createMethodDeclaration(
                        node.modifiers,
                        node.asteriskToken,
                        '_init',
                        node.questionToken,
                        node.typeParameters,
                        node.parameters,
                        node.type,
                        // Visit each child to replace any super constrcutor reference
                        ts.visitEachChild(node.body, constructorBodyVisitor, context)
                    );
                }

                return node;
            };

            const visitor = (node: ts.Node): ts.Node => {
                if (ts.isClassDeclaration(node) || ts.isClassExpression(node)) {
                    className = node.name?.getText();
                    if (className && this.gobjects.indexOf(className) != -1) {
                        return ts.visitEachChild(node, gobjectClassVisitor, context);
                    }
                }

                return ts.visitEachChild(node, visitor, context);
            };

            return ts.visitNode(sourceFile, visitor);
        };
    }

    private isDecoratedClass(node: ts.ClassDeclaration, decorator: string): boolean{
        const decorators = ts.getDecorators(node) || [];
        if (decorators.length == 0) {
            return false;
        }

        return decorators.find(n => n.getText() == decorator) !== undefined;
    }
}
